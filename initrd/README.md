# ovm initrd

制作 initrd

## 项目结构

```txt
.
├── bin/
│   ├── batch-download      # 这是一个独立的用来批量下载包的脚本
│   ├── build               # 这个是用来定义父类方法的shell脚本
│   ├── finally             # 这个是一切都就绪后最后执行的独立脚本
│   ├── musl-toolchain      # 这个是一个用于独立编译交叉工具链的脚本
│   └── munge-config-sub
├── config/
│   ├── busybox.config          # 这是已经预先设置好的busybox配置，整体上与具体处理器无关
│   ├── download.list           # 这个文件里面定义了各个所需软件包的文件名和下载地址
│   ├── init.sh                 # 这个是最后用于启动系统的初始化脚本
├── lib/
│   ├── box/                # 这个目录里放的是最后要给成品装箱需要运行的各个软件的脚本
│   ├── host_deps.bash      # 这个文件用于检查宿主环境的工具链所需的基本依赖，可以参考OpenWrt
│   ├── misc.bash
│   └── ready.bash
├── output/     # 最后输出成品库的目录
│   ├── aarch64
│   └── x86_64
├── patches/    # 存放补丁包的下载目录
├── sources/    # 存放批量下载的源代码包
│   ├── binutils-2.40.tar.xz
│   ├── gcc-12.3.0.tar.xz
│   ├── gmp-6.3.0.tar.xz
│   ├── isl-0.24.tar.bz2
│   ├── mpc-1.3.1.tar.gz
│   ├── mpfr-4.2.1.tar.xz
│   └── musl-1.2.4.tar.gz
├── states/         # 用状态文件记录构建进度
│   ├── await-*       # 每个包编译成功后给这个文件清零，失败就会从这个文件里记录的包名结束
│   ├── box-*
│   └── cross-*
├── toolchain/      # 交叉工具链脚本编译后输出的位置
│   ├── aarch64/
│   └── x86_64/
├── work/           # 临时解压代码包编译使用的位置
├── bootstrap.bash  # 构建工具的入口
├── Makefile        # 使用Makefile可以有利于工程化管理
└── README.md

```

#### 目录解析

1. 项目脚本常用工具命令都放到了bin目录中，在boostrap脚本里已加入到PATH环境变量里
2. config目录用于存放需要复制到目标sysroot里面或者源代码构建目录里面的文件
3. lib里面两个目录用于存放两个构建步骤的组件编译脚本
4. sources目录里面只有做交叉工具链的时候会有目录残留，如果检查到有残留目录，需要先删除掉
5. states目录存放的是每个步骤完成的状态，步骤文件会记录已构建完成的包名
6. work目录是每次编译成功都会清除解压的目录，存在残留就说明有包编译失败


## 使用方法

- 帮助信息

```bash
make
```

- 编译`x86_64`或`amd64`目标系统

```bash
make x86_64
```

- 编译`aarch64`或`arm64`目标系统

```bash
make aarch64
```

- 批量下载代码包

```bash
make download
```

- 单独编译交叉工具链

```bash
make DEST=aarch64 crosstool
```


## 项目原理

通过对LFS的认真研究学习，总结了一套不用经历三阶段编译的自举流程，其中采用了作者 @kukrimate 编写的工具链自举脚本。
[musl-bootstrap.sh](https://gist.github.com/kukrimate/79c5da47eb92cc86f2307d60fa75b3e4)

批量下载脚本采用了wget的断点续传功能，会根据文件已传大小和时间戳决定是否下载重复的文件。

主要流程是通过将交叉工具链的bin目录加到PATH环境变量的开头，让后续的软件编译过程中优先选择已编译出的GCC工具链。

把最小依赖的库排到最优先的位置安装，然后把安装后的usr/lib目录加到链接库的查找路径`LIBRARY_PATH`环境变量开头，
实现最终靠编译出的库链接后续的软件，消除对宿主环境的依赖，这个方法同样对Docker容器环境构建有效。


#### 增量编译

本项目有一个非常重要的功能就是支持增量构建，可以从任意一个位置停止，然后在work目录中看到暂停的包。

在states目录中可以看到await文件的状态，这个是增量编译的前提，每次编译的任意位置给函数返回非0的值，
await就会记录当时停下的包，在后续调试的时候，删除掉work目录下的脏环境，就可以从await的记录重新编译那个包了。

同样还有一个也是核心的特色就是在所有包都编译完之后，可以随时手动往里面加文件，然后执行 `make aarch64|x86_64`
这样的编译命令，就会重新打包boxroot目录，这样可以跳过编译的过程，直接利用已生成的结构打包一遍，提高开发效率。


## 注意事项

目前项目仍存在的问题是在任意一个包安装出错后再重新运行，会因为旧的解压的代码没清理会导致重新执行make会失败，
这个问题可以通过手动删除 work 目录下的源码目录的方式解决。


## 报错处理方法

编译到任何包的步骤发生报错以后，states目录里await文件会记录卡住的包名，另外还可以在项目的context.log日志文件里面看到可供排查问题的信息


## 增加补丁

补丁文件通常是以 `名称-版本号.patch` 的格式命名，放到patches目录中，如果后续要对某个包进行升级，可以参考buildroot和openwrt的PR记录。

OpenWRT的PR修复的问题对本项目同样可以使用。


----
Copyright (c) 2011 - 2013 by @pikhq
Copyright (c) 2023 by @gnuos


